// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: blockchain.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018-2022 The MobileCoin Foundation

// Blockchain-related data types.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Block ID.
public struct Blockchain_BlockID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Hash of the block's contents.
public struct Blockchain_BlockContentsHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A block in the blockchain.
public struct Blockchain_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Block ID.
  public var id: Blockchain_BlockID {
    get {return _id ?? Blockchain_BlockID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// Block format version.
  public var version: UInt32 = 0

  /// Id of the previous block.
  public var parentID: Blockchain_BlockID {
    get {return _parentID ?? Blockchain_BlockID()}
    set {_parentID = newValue}
  }
  /// Returns true if `parentID` has been explicitly set.
  public var hasParentID: Bool {return self._parentID != nil}
  /// Clears the value of `parentID`. Subsequent reads from it will return its default value.
  public mutating func clearParentID() {self._parentID = nil}

  /// The index of this block in the blockchain.
  public var index: UInt64 = 0

  /// The cumulative number of TXOs in the blockchain, including this block
  public var cumulativeTxoCount: UInt64 = 0

  /// Root hash of the membership proofs provided by the untrusted local system for validation.
  /// This captures the state of all TxOuts in the ledger that this block was validated against.
  public var rootElement: External_TxOutMembershipElement {
    get {return _rootElement ?? External_TxOutMembershipElement()}
    set {_rootElement = newValue}
  }
  /// Returns true if `rootElement` has been explicitly set.
  public var hasRootElement: Bool {return self._rootElement != nil}
  /// Clears the value of `rootElement`. Subsequent reads from it will return its default value.
  public mutating func clearRootElement() {self._rootElement = nil}

  /// Hash of the block's contents.
  public var contentsHash: Blockchain_BlockContentsHash {
    get {return _contentsHash ?? Blockchain_BlockContentsHash()}
    set {_contentsHash = newValue}
  }
  /// Returns true if `contentsHash` has been explicitly set.
  public var hasContentsHash: Bool {return self._contentsHash != nil}
  /// Clears the value of `contentsHash`. Subsequent reads from it will return its default value.
  public mutating func clearContentsHash() {self._contentsHash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Blockchain_BlockID? = nil
  fileprivate var _parentID: Blockchain_BlockID? = nil
  fileprivate var _rootElement: External_TxOutMembershipElement? = nil
  fileprivate var _contentsHash: Blockchain_BlockContentsHash? = nil
}

public struct Blockchain_BlockContents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key images spent in this block.
  public var keyImages: [External_KeyImage] = []

  /// Outputs created in this block.
  public var outputs: [External_TxOut] = []

  //// mint-config transactions in this block coupled with data used to validate them.
  public var validatedMintConfigTxs: [External_ValidatedMintConfigTx] = []

  //// Mint transactions in this block.
  public var mintTxs: [External_MintTx] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Blockchain_BlockSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The signature of the block.
  public var signature: External_Ed25519Signature {
    get {return _signature ?? External_Ed25519Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// The signer that generated the above signature.
  public var signer: External_Ed25519Public {
    get {return _signer ?? External_Ed25519Public()}
    set {_signer = newValue}
  }
  /// Returns true if `signer` has been explicitly set.
  public var hasSigner: Bool {return self._signer != nil}
  /// Clears the value of `signer`. Subsequent reads from it will return its default value.
  public mutating func clearSigner() {self._signer = nil}

  /// An approximate time in which the block was signed.
  /// Represented as seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.
  public var signedAt: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _signature: External_Ed25519Signature? = nil
  fileprivate var _signer: External_Ed25519Public? = nil
}

public struct Blockchain_BlockMetadataContents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Block ID.
  public var blockID: Blockchain_BlockID {
    get {return _blockID ?? Blockchain_BlockID()}
    set {_blockID = newValue}
  }
  /// Returns true if `blockID` has been explicitly set.
  public var hasBlockID: Bool {return self._blockID != nil}
  /// Clears the value of `blockID`. Subsequent reads from it will return its default value.
  public mutating func clearBlockID() {self._blockID = nil}

  /// Quorum set configuration at the time of externalization.
  public var quorumSet: QuorumSet_QuorumSet {
    get {return _quorumSet ?? QuorumSet_QuorumSet()}
    set {_quorumSet = newValue}
  }
  /// Returns true if `quorumSet` has been explicitly set.
  public var hasQuorumSet: Bool {return self._quorumSet != nil}
  /// Clears the value of `quorumSet`. Subsequent reads from it will return its default value.
  public mutating func clearQuorumSet() {self._quorumSet = nil}

  /// The attestation evidence for the enclave which generated the signature.
  public var attestationEvidence: Blockchain_BlockMetadataContents.OneOf_AttestationEvidence? = nil

  public var verificationReport: External_VerificationReport {
    get {
      if case .verificationReport(let v)? = attestationEvidence {return v}
      return External_VerificationReport()
    }
    set {attestationEvidence = .verificationReport(newValue)}
  }

  public var dcapEvidence: External_DcapEvidence {
    get {
      if case .dcapEvidence(let v)? = attestationEvidence {return v}
      return External_DcapEvidence()
    }
    set {attestationEvidence = .dcapEvidence(newValue)}
  }

  /// Responder ID of the consensus node that externalized this block.
  public var responderID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The attestation evidence for the enclave which generated the signature.
  public enum OneOf_AttestationEvidence: Equatable {
    case verificationReport(External_VerificationReport)
    case dcapEvidence(External_DcapEvidence)

  #if !swift(>=4.1)
    public static func ==(lhs: Blockchain_BlockMetadataContents.OneOf_AttestationEvidence, rhs: Blockchain_BlockMetadataContents.OneOf_AttestationEvidence) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.verificationReport, .verificationReport): return {
        guard case .verificationReport(let l) = lhs, case .verificationReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dcapEvidence, .dcapEvidence): return {
        guard case .dcapEvidence(let l) = lhs, case .dcapEvidence(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _blockID: Blockchain_BlockID? = nil
  fileprivate var _quorumSet: QuorumSet_QuorumSet? = nil
}

public struct Blockchain_BlockMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata signed by the consensus node.
  public var contents: Blockchain_BlockMetadataContents {
    get {return _storage._contents ?? Blockchain_BlockMetadataContents()}
    set {_uniqueStorage()._contents = newValue}
  }
  /// Returns true if `contents` has been explicitly set.
  public var hasContents: Bool {return _storage._contents != nil}
  /// Clears the value of `contents`. Subsequent reads from it will return its default value.
  public mutating func clearContents() {_uniqueStorage()._contents = nil}

  /// Message signing key (signer).
  public var nodeKey: External_Ed25519Public {
    get {return _storage._nodeKey ?? External_Ed25519Public()}
    set {_uniqueStorage()._nodeKey = newValue}
  }
  /// Returns true if `nodeKey` has been explicitly set.
  public var hasNodeKey: Bool {return _storage._nodeKey != nil}
  /// Clears the value of `nodeKey`. Subsequent reads from it will return its default value.
  public mutating func clearNodeKey() {_uniqueStorage()._nodeKey = nil}

  /// Signature using `node_key` over the Digestible encoding of `contents`.
  public var signature: External_Ed25519Signature {
    get {return _storage._signature ?? External_Ed25519Signature()}
    set {_uniqueStorage()._signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return _storage._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {_uniqueStorage()._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Version 1 of an archived block.
/// Note: The block.version field within the block may or may not be equal to 1.
public struct Blockchain_ArchiveBlockV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The block (header).
  public var block: Blockchain_Block {
    get {return _storage._block ?? Blockchain_Block()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {_uniqueStorage()._block = nil}

  /// Contents of the block.
  public var blockContents: Blockchain_BlockContents {
    get {return _storage._blockContents ?? Blockchain_BlockContents()}
    set {_uniqueStorage()._blockContents = newValue}
  }
  /// Returns true if `blockContents` has been explicitly set.
  public var hasBlockContents: Bool {return _storage._blockContents != nil}
  /// Clears the value of `blockContents`. Subsequent reads from it will return its default value.
  public mutating func clearBlockContents() {_uniqueStorage()._blockContents = nil}

  /// Block signature, when available.
  public var signature: Blockchain_BlockSignature {
    get {return _storage._signature ?? Blockchain_BlockSignature()}
    set {_uniqueStorage()._signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return _storage._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {_uniqueStorage()._signature = nil}

  /// Additional signed metadata about this block.
  public var metadata: Blockchain_BlockMetadata {
    get {return _storage._metadata ?? Blockchain_BlockMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An archived block.
public struct Blockchain_ArchiveBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var block: Blockchain_ArchiveBlock.OneOf_Block? = nil

  public var v1: Blockchain_ArchiveBlockV1 {
    get {
      if case .v1(let v)? = block {return v}
      return Blockchain_ArchiveBlockV1()
    }
    set {block = .v1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Block: Equatable {
    case v1(Blockchain_ArchiveBlockV1)

  #if !swift(>=4.1)
    public static func ==(lhs: Blockchain_ArchiveBlock.OneOf_Block, rhs: Blockchain_ArchiveBlock.OneOf_Block) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v1, .v1): return {
        guard case .v1(let l) = lhs, case .v1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// A collection of archived blocks.
public struct Blockchain_ArchiveBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blocks: [Blockchain_ArchiveBlock] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Blockchain_BlockID: @unchecked Sendable {}
extension Blockchain_BlockContentsHash: @unchecked Sendable {}
extension Blockchain_Block: @unchecked Sendable {}
extension Blockchain_BlockContents: @unchecked Sendable {}
extension Blockchain_BlockSignature: @unchecked Sendable {}
extension Blockchain_BlockMetadataContents: @unchecked Sendable {}
extension Blockchain_BlockMetadataContents.OneOf_AttestationEvidence: @unchecked Sendable {}
extension Blockchain_BlockMetadata: @unchecked Sendable {}
extension Blockchain_ArchiveBlockV1: @unchecked Sendable {}
extension Blockchain_ArchiveBlock: @unchecked Sendable {}
extension Blockchain_ArchiveBlock.OneOf_Block: @unchecked Sendable {}
extension Blockchain_ArchiveBlocks: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "blockchain"

extension Blockchain_BlockID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_BlockID, rhs: Blockchain_BlockID) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_BlockContentsHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockContentsHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_BlockContentsHash, rhs: Blockchain_BlockContentsHash) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Block"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "version"),
    3: .standard(proto: "parent_id"),
    4: .same(proto: "index"),
    5: .standard(proto: "cumulative_txo_count"),
    6: .standard(proto: "root_element"),
    7: .standard(proto: "contents_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._parentID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.cumulativeTxoCount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._rootElement) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._contentsHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    try { if let v = self._parentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 4)
    }
    if self.cumulativeTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.cumulativeTxoCount, fieldNumber: 5)
    }
    try { if let v = self._rootElement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._contentsHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_Block, rhs: Blockchain_Block) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.version != rhs.version {return false}
    if lhs._parentID != rhs._parentID {return false}
    if lhs.index != rhs.index {return false}
    if lhs.cumulativeTxoCount != rhs.cumulativeTxoCount {return false}
    if lhs._rootElement != rhs._rootElement {return false}
    if lhs._contentsHash != rhs._contentsHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_BlockContents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockContents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_images"),
    2: .same(proto: "outputs"),
    3: .standard(proto: "validated_mint_config_txs"),
    4: .standard(proto: "mint_txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keyImages) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.validatedMintConfigTxs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.mintTxs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyImages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyImages, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    if !self.validatedMintConfigTxs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validatedMintConfigTxs, fieldNumber: 3)
    }
    if !self.mintTxs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mintTxs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_BlockContents, rhs: Blockchain_BlockContents) -> Bool {
    if lhs.keyImages != rhs.keyImages {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.validatedMintConfigTxs != rhs.validatedMintConfigTxs {return false}
    if lhs.mintTxs != rhs.mintTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_BlockSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockSignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .same(proto: "signer"),
    3: .standard(proto: "signed_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signer) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.signedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.signedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.signedAt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_BlockSignature, rhs: Blockchain_BlockSignature) -> Bool {
    if lhs._signature != rhs._signature {return false}
    if lhs._signer != rhs._signer {return false}
    if lhs.signedAt != rhs.signedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_BlockMetadataContents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockMetadataContents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_id"),
    2: .standard(proto: "quorum_set"),
    3: .standard(proto: "verification_report"),
    5: .standard(proto: "dcap_evidence"),
    4: .standard(proto: "responder_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._quorumSet) }()
      case 3: try {
        var v: External_VerificationReport?
        var hadOneofValue = false
        if let current = self.attestationEvidence {
          hadOneofValue = true
          if case .verificationReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attestationEvidence = .verificationReport(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.responderID) }()
      case 5: try {
        var v: External_DcapEvidence?
        var hadOneofValue = false
        if let current = self.attestationEvidence {
          hadOneofValue = true
          if case .dcapEvidence(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attestationEvidence = .dcapEvidence(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._quorumSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if case .verificationReport(let v)? = self.attestationEvidence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.responderID.isEmpty {
      try visitor.visitSingularStringField(value: self.responderID, fieldNumber: 4)
    }
    try { if case .dcapEvidence(let v)? = self.attestationEvidence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_BlockMetadataContents, rhs: Blockchain_BlockMetadataContents) -> Bool {
    if lhs._blockID != rhs._blockID {return false}
    if lhs._quorumSet != rhs._quorumSet {return false}
    if lhs.attestationEvidence != rhs.attestationEvidence {return false}
    if lhs.responderID != rhs.responderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_BlockMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contents"),
    2: .standard(proto: "node_key"),
    3: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _contents: Blockchain_BlockMetadataContents? = nil
    var _nodeKey: External_Ed25519Public? = nil
    var _signature: External_Ed25519Signature? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _contents = source._contents
      _nodeKey = source._nodeKey
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._contents) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._nodeKey) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._signature) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._contents {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._nodeKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._signature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_BlockMetadata, rhs: Blockchain_BlockMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contents != rhs_storage._contents {return false}
        if _storage._nodeKey != rhs_storage._nodeKey {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_ArchiveBlockV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveBlockV1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .standard(proto: "block_contents"),
    3: .same(proto: "signature"),
    4: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _block: Blockchain_Block? = nil
    var _blockContents: Blockchain_BlockContents? = nil
    var _signature: Blockchain_BlockSignature? = nil
    var _metadata: Blockchain_BlockMetadata? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _block = source._block
      _blockContents = source._blockContents
      _signature = source._signature
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._block) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._blockContents) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._signature) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._blockContents {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._signature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_ArchiveBlockV1, rhs: Blockchain_ArchiveBlockV1) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._block != rhs_storage._block {return false}
        if _storage._blockContents != rhs_storage._blockContents {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_ArchiveBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Blockchain_ArchiveBlockV1?
        var hadOneofValue = false
        if let current = self.block {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.block = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v1(let v)? = self.block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_ArchiveBlock, rhs: Blockchain_ArchiveBlock) -> Bool {
    if lhs.block != rhs.block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_ArchiveBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_ArchiveBlocks, rhs: Blockchain_ArchiveBlocks) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
