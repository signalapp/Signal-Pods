// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ledger.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018-2022 The MobileCoin Foundation

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

//// The status associated with a MultiKeyImageStoreQueryResponse
public enum FogLedger_MultiKeyImageStoreResponseStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  //// Ensure default value (unfilled status) doesn't falsely appear to be a success 
  case unknown // = 0

  //// The Fog Ledger Store successfully fulfilled the request.
  case success // = 1

  //// The Fog Ledger Store is unable to decrypt a query within the MultiKeyImageStoreRequest. It needs to be authenticated
  //// by the router.
  case authenticationError // = 2

  //// The Fog Ledger Store is not ready to service a MultiLedgerStoreQueryRequest. This might be because the store has
  //// not loaded enough blocks yet.
  case notReady // = 3

  //// The Fog Ledger Store could not decode the protobuf message.
  case invalidArgument // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .success
    case 2: self = .authenticationError
    case 3: self = .notReady
    case 4: self = .invalidArgument
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .success: return 1
    case .authenticationError: return 2
    case .notReady: return 3
    case .invalidArgument: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FogLedger_MultiKeyImageStoreResponseStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [FogLedger_MultiKeyImageStoreResponseStatus] = [
    .unknown,
    .success,
    .authenticationError,
    .notReady,
    .invalidArgument,
  ]
}

#endif  // swift(>=4.2)

//// The logical result of an individual index in a GetOutputs request
public enum FogLedger_OutputResultCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  //// The default value for fixed32 is intentionally unused to avoid omitting this field
  case intentionallyUnused // = 0

  //// A TxOut with this index was not found in the ledger (it is out of bounds)
  case doesNotExist // = 1

  //// A TxOut with this index was found and the output and merkle-proof are provided
  case exists // = 2

  //// A database error prevented us from satisfying the request
  case outputDatabaseError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .intentionallyUnused
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .intentionallyUnused
    case 1: self = .doesNotExist
    case 2: self = .exists
    case 3: self = .outputDatabaseError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .intentionallyUnused: return 0
    case .doesNotExist: return 1
    case .exists: return 2
    case .outputDatabaseError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FogLedger_OutputResultCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [FogLedger_OutputResultCode] = [
    .intentionallyUnused,
    .doesNotExist,
    .exists,
    .outputDatabaseError,
  ]
}

#endif  // swift(>=4.2)

//// The result code indicating whether the spent_at block was found.
public enum FogLedger_KeyImageResultCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  //// The default value for fixed32 is intentionally unused to avoid omitting this field.
  case unused // = 0

  //// The key image has been spent, and the spent_at value was found.
  case spent // = 1

  //// The key image has not been spent.
  case notSpent // = 2

  //// Error occurred when getting key image
  case keyImageError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unused
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unused
    case 1: self = .spent
    case 2: self = .notSpent
    case 3: self = .keyImageError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unused: return 0
    case .spent: return 1
    case .notSpent: return 2
    case .keyImageError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FogLedger_KeyImageResultCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [FogLedger_KeyImageResultCode] = [
    .unused,
    .spent,
    .notSpent,
    .keyImageError,
  ]
}

#endif  // swift(>=4.2)

public enum FogLedger_TxOutResultCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case notFound // = 0
  case found // = 1
  case malformedRequest // = 2
  case databaseError // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notFound
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notFound
    case 1: self = .found
    case 2: self = .malformedRequest
    case 3: self = .databaseError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notFound: return 0
    case .found: return 1
    case .malformedRequest: return 2
    case .databaseError: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FogLedger_TxOutResultCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [FogLedger_TxOutResultCode] = [
    .notFound,
    .found,
    .malformedRequest,
    .databaseError,
  ]
}

#endif  // swift(>=4.2)

public struct FogLedger_LedgerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestData: FogLedger_LedgerRequest.OneOf_RequestData? = nil

  public var auth: Attest_AuthMessage {
    get {
      if case .auth(let v)? = requestData {return v}
      return Attest_AuthMessage()
    }
    set {requestData = .auth(newValue)}
  }

  /// TODO: Fill in block query service and merkle proof service.
  /// Potentially untrusted_tx_out_service? To be decided.     
  public var checkKeyImages: Attest_Message {
    get {
      if case .checkKeyImages(let v)? = requestData {return v}
      return Attest_Message()
    }
    set {requestData = .checkKeyImages(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_RequestData: Equatable {
    case auth(Attest_AuthMessage)
    /// TODO: Fill in block query service and merkle proof service.
    /// Potentially untrusted_tx_out_service? To be decided.     
    case checkKeyImages(Attest_Message)

  #if !swift(>=4.1)
    public static func ==(lhs: FogLedger_LedgerRequest.OneOf_RequestData, rhs: FogLedger_LedgerRequest.OneOf_RequestData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.auth, .auth): return {
        guard case .auth(let l) = lhs, case .auth(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.checkKeyImages, .checkKeyImages): return {
        guard case .checkKeyImages(let l) = lhs, case .checkKeyImages(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct FogLedger_LedgerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responseData: FogLedger_LedgerResponse.OneOf_ResponseData? = nil

  public var auth: Attest_AuthMessage {
    get {
      if case .auth(let v)? = responseData {return v}
      return Attest_AuthMessage()
    }
    set {responseData = .auth(newValue)}
  }

  /// TODO: Fill in block query service and merkle proof service.
  /// Potentially untrusted_tx_out_service? To be decided.     
  public var checkKeyImageResponse: Attest_Message {
    get {
      if case .checkKeyImageResponse(let v)? = responseData {return v}
      return Attest_Message()
    }
    set {responseData = .checkKeyImageResponse(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ResponseData: Equatable {
    case auth(Attest_AuthMessage)
    /// TODO: Fill in block query service and merkle proof service.
    /// Potentially untrusted_tx_out_service? To be decided.     
    case checkKeyImageResponse(Attest_Message)

  #if !swift(>=4.1)
    public static func ==(lhs: FogLedger_LedgerResponse.OneOf_ResponseData, rhs: FogLedger_LedgerResponse.OneOf_ResponseData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.auth, .auth): return {
        guard case .auth(let l) = lhs, case .auth(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.checkKeyImageResponse, .checkKeyImageResponse): return {
        guard case .checkKeyImageResponse(let l) = lhs, case .checkKeyImageResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Identical to FogViewStoreDecryptionError
public struct FogLedger_FogLedgerStoreDecryptionError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The FogLedgerStoreUri for the specific Fog Ledger Store that
  //// tried to decrypt the MultiKeyImageStoreRequest and failed.
  //// The client should subsequently authenticate with the machine
  //// described by this URI.
  public var storeUri: String = String()

  //// An error message that describes the decryption error.
  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Identical to MultiViewStoreQueryRequest
public struct FogLedger_MultiKeyImageStoreRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// A list of queries encrypted for Fog Ledger Stores.
  public var queries: [Attest_NonceMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_MultiKeyImageStoreResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Optional field that gets set when the Fog Ledger Store is able to decrypt a query
  //// included in the MultiKeyImageStoreRequest and create a query response for that
  ///  query. This is an encrypted CheckKeyImagesResponse.
  public var queryResponse: Attest_NonceMessage {
    get {return _queryResponse ?? Attest_NonceMessage()}
    set {_queryResponse = newValue}
  }
  /// Returns true if `queryResponse` has been explicitly set.
  public var hasQueryResponse: Bool {return self._queryResponse != nil}
  /// Clears the value of `queryResponse`. Subsequent reads from it will return its default value.
  public mutating func clearQueryResponse() {self._queryResponse = nil}

  //// The FogLedgerStore for the specific Fog Ledger Store that
  //// tried to decrypt the MultiLedgerStoreQueryRequest and failed.
  //// The client should subsequently authenticate with the machine
  //// described by this URI.
  public var storeUri: String = String()

  //// Status that gets returned when the Fog Ledger Store services a MultiKeyImageStoreRequest.
  public var status: FogLedger_MultiKeyImageStoreResponseStatus = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _queryResponse: Attest_NonceMessage? = nil
}

public struct FogLedger_GetOutputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The global txout indices being requested
  public var indices: [UInt64] = []

  //// The common merkle-root block that all the proofs should share
  public var merkleRootBlock: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_GetOutputsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The outputs that we found
  public var results: [FogLedger_OutputResult] = []

  //// The total number of blocks in the ledger at the time the request is evaluated
  public var numBlocks: UInt64 = 0

  //// The total number of Txos in the ledger at the time the request is evaluated
  public var globalTxoCount: UInt64 = 0

  //// The latest block_version of a block in the block chain
  ////
  //// This may be needed when building transactions, so that use of new transaction
  //// features can be gated on the block version being increased.
  ////
  //// Clients may also choose to prompt users to update their software if
  //// the block version increases beyond what was "known" when the software
  //// was built.
  public var latestBlockVersion: UInt32 = 0

  //// The max of latest_block_version and the MAX_BLOCK_VERSION value
  //// in mc-transaction-core (in this deploy of fog ledger).
  ////
  //// Usually when we redeploy consensus, we also redeploy fog. So this should
  //// usually be equal to the MAX_BLOCK_VERSION value in the consensus enclave.
  //// (In case it isn't, it won't be less than latest_block_version.)
  ////
  //// This is possibly an additional signal that clients can use to discover
  //// that there is a new version of transaction-core that may be available
  //// for an update (by comparing to their local value of max_block_version).
  public var maxBlockVersion: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_OutputResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The global txout index that was queried
  public var index: UInt64 = 0

  //// A status code indicating the result of the query
  //// This is fixed32 to avoid leaking information about found / not found
  //// in the size of the encrypted payload.
  //// The possible values are described in enum OutputResultCode
  public var resultCode: UInt32 = 0

  //// The output that we found
  public var output: External_TxOut {
    get {return _output ?? External_TxOut()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {self._output = nil}

  //// The merkle proof for that output
  public var proof: External_TxOutMembershipProof {
    get {return _proof ?? External_TxOutMembershipProof()}
    set {_proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  public var hasProof: Bool {return self._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  public mutating func clearProof() {self._proof = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _output: External_TxOut? = nil
  fileprivate var _proof: External_TxOutMembershipProof? = nil
}

public struct FogLedger_CheckKeyImagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// A list of key images queries, to check if they have appeared in the ledger
  //// already, and if so, in what block.
  public var queries: [FogLedger_KeyImageQuery] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_KeyImageQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The key image to check.
  public var keyImage: External_KeyImage {
    get {return _keyImage ?? External_KeyImage()}
    set {_keyImage = newValue}
  }
  /// Returns true if `keyImage` has been explicitly set.
  public var hasKeyImage: Bool {return self._keyImage != nil}
  /// Clears the value of `keyImage`. Subsequent reads from it will return its default value.
  public mutating func clearKeyImage() {self._keyImage = nil}

  //// An optional start_block to start searching forward from when performing the check.
  ////
  //// Note:
  //// A correct implementation of the server may ignore this, it is an optimization.
  //// This may help scaling because then for daily active users we won't have to
  //// obliviously scan the whole set to support their queries.
  public var startBlock: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyImage: External_KeyImage? = nil
}

//// A response to a request for key image checks
////
//// Contracts:
//// If a KeyImageResult comes back with spent_at != 0, then it was spent in that block index.
//// If a KeyImageResult comes back with spent_at == 0, then it was NOT spent, AT LEAST as of
//// resp.block_height (the top level block height number). It is possible that it WAS actually
//// spent in resp.block_height + 1, but the server didn't know, or didn't figure that out.
public struct FogLedger_CheckKeyImagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The number of blocks in the ledger at the time that the request was evaluated.
  ////
  //// Note: This may be a conservative estimate, in the sense of being a lower bound.
  //// It's allowed that the data is "more fresh" than we are telling the client, but not less fresh.
  ////
  //// Implementation note: If the server does not evaluate all the key image checks as one
  //// database transaction, then this number should be a lower bound on the num_blocks across
  //// all of those database transactions.
  public var numBlocks: UInt64 = 0

  //// The number of txos in the ledger at the time that the request was evaluated.
  public var globalTxoCount: UInt64 = 0

  //// The results for each key image query
  public var results: [FogLedger_KeyImageResult] = []

  //// The latest block_version of a block in the block chain
  ////
  //// This may be needed when building transactions, so that use of new transaction
  //// features can be gated on the block version being increased.
  ////
  //// Clients may also choose to prompt users to update their software if
  //// the block version increases beyond what was "known" when the software
  //// was built.
  public var latestBlockVersion: UInt32 = 0

  //// The max of latest_block_version and the MAX_BLOCK_VERSION value
  //// in mc-transaction-core (in this deploy of fog ledger).
  ////
  //// Usually when we redeploy consensus, we also redeploy fog. So this should
  //// usually be equal to the MAX_BLOCK_VERSION value in the consensus enclave.
  //// (In case it isn't, it won't be less than latest_block_version.)
  ////
  //// This is possibly an additional signal that clients can use to discover
  //// that there is a new version of transaction-core that may be available
  //// for an update (by comparing to their local value of max_block_version).
  public var maxBlockVersion: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_KeyImageResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The key image that was queried.
  public var keyImage: External_KeyImage {
    get {return _keyImage ?? External_KeyImage()}
    set {_keyImage = newValue}
  }
  /// Returns true if `keyImage` has been explicitly set.
  public var hasKeyImage: Bool {return self._keyImage != nil}
  /// Clears the value of `keyImage`. Subsequent reads from it will return its default value.
  public mutating func clearKeyImage() {self._keyImage = nil}

  //// The block index at which it was spent.
  //// Note, spent_at is only valid if key_image_result_code == Spent. If
  //// key_image_result_code is not Spent, then spent_at is undefined, but > 0.
  public var spentAt: UInt64 = 0

  //// The timestamp of the block containing this key image.
  //// The value is u64::MAX if the timestamp cannot be found.
  //// If the timestamp cannot be found, even when key_image_result_code == Spent,
  //// that represents an internal error of the server
  //// which should be reported to the developers.
  //// Note: The timestamps are based on untrusted reporting of time from the consensus validators.
  //// Represented as seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.
  public var timestamp: UInt64 = 0

  //// The result code indicating whether the timestamp was found, can be tried again later, or will
  //// never be found with the current configuration of the Key Image Service's watcher.
  //// This is fixed32 to avoid leaking information about found / not found in the size of the encrypted
  //// payload.
  //// The possible values are described in enum TimestampResultCode.
  //// This is a legacy result code which was forwarded by ledger server from the Watcher db API if a timestamp is not available.
  //// The ledger server now handles all of these errors and the result will always be `TimestampFound`.
  //// Clients should ignore this value, and in a future revision we may make it always zero.
  public var timestampResultCode: UInt32 = 0

  //// The result code indicating whether the key image was spent.
  //// The possible values are described in enum KeyImageResultCode.
  public var keyImageResultCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyImage: External_KeyImage? = nil
}

public struct FogLedger_BlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// A request formulated as several ranges of block indices
  public var ranges: [FogCommon_BlockRange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_BlockResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The block data returned by the server
  public var blocks: [FogLedger_BlockData] = []

  //// The total number of blocks in the ledger at the time the request is evaluated
  public var numBlocks: UInt64 = 0

  //// The total number of Txos in the ledger at the time the request is evaluated
  public var globalTxoCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_BlockData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The index of the block in the blockchain
  public var index: UInt64 = 0

  //// The cumulative number of Txos in the blockchain, including this block
  public var globalTxoCount: UInt64 = 0

  //// The TxOuts of this block in consecutive order
  public var outputs: [External_TxOut] = []

  //// The timestamp of the block (if timestamp is available)
  public var timestamp: UInt64 = 0

  //// Indicates if the block had a timestamp
  //// The possible values are described in enum TimestampResultCode.
  public var timestampResultCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_TxOutRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The TxOut.pubkey (compressed ristretto point bytes) of interest
  //// This is repeated so that several logical queries can be bundled into one
  //// grpc request.
  public var txOutPubkeys: [External_CompressedRistretto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_TxOutResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The results corresponding to each tx_out_pubkey request
  public var results: [FogLedger_TxOutResult] = []

  //// The total number of blocks in the ledger at the time the request is evaluated
  //// tx_out_pubkeys which are NotFound are guaranteed not to have appeared in the blockchain
  //// in any block of index less than this value.
  public var numBlocks: UInt64 = 0

  //// The total number of Txos in the ledger at the time the request is evaluated
  public var globalTxoCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FogLedger_TxOutResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The query that this result corresponds to
  public var txOutPubkey: External_CompressedRistretto {
    get {return _txOutPubkey ?? External_CompressedRistretto()}
    set {_txOutPubkey = newValue}
  }
  /// Returns true if `txOutPubkey` has been explicitly set.
  public var hasTxOutPubkey: Bool {return self._txOutPubkey != nil}
  /// Clears the value of `txOutPubkey`. Subsequent reads from it will return its default value.
  public mutating func clearTxOutPubkey() {self._txOutPubkey = nil}

  //// A status code indicating the result of the query
  public var resultCode: FogLedger_TxOutResultCode = .notFound

  //// The global index of this tx out (if found)
  public var txOutGlobalIndex: UInt64 = 0

  //// The block index of this tx out (if found)
  public var blockIndex: UInt64 = 0

  //// The timestamp of the block of this tx out (if found and timestamp is available)
  public var timestamp: UInt64 = 0

  //// Indicates if the block had a timestamp (if tx out was found)
  //// The possible values are described in enum TimestampResultCode.
  public var timestampResultCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _txOutPubkey: External_CompressedRistretto? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension FogLedger_MultiKeyImageStoreResponseStatus: @unchecked Sendable {}
extension FogLedger_OutputResultCode: @unchecked Sendable {}
extension FogLedger_KeyImageResultCode: @unchecked Sendable {}
extension FogLedger_TxOutResultCode: @unchecked Sendable {}
extension FogLedger_LedgerRequest: @unchecked Sendable {}
extension FogLedger_LedgerRequest.OneOf_RequestData: @unchecked Sendable {}
extension FogLedger_LedgerResponse: @unchecked Sendable {}
extension FogLedger_LedgerResponse.OneOf_ResponseData: @unchecked Sendable {}
extension FogLedger_FogLedgerStoreDecryptionError: @unchecked Sendable {}
extension FogLedger_MultiKeyImageStoreRequest: @unchecked Sendable {}
extension FogLedger_MultiKeyImageStoreResponse: @unchecked Sendable {}
extension FogLedger_GetOutputsRequest: @unchecked Sendable {}
extension FogLedger_GetOutputsResponse: @unchecked Sendable {}
extension FogLedger_OutputResult: @unchecked Sendable {}
extension FogLedger_CheckKeyImagesRequest: @unchecked Sendable {}
extension FogLedger_KeyImageQuery: @unchecked Sendable {}
extension FogLedger_CheckKeyImagesResponse: @unchecked Sendable {}
extension FogLedger_KeyImageResult: @unchecked Sendable {}
extension FogLedger_BlockRequest: @unchecked Sendable {}
extension FogLedger_BlockResponse: @unchecked Sendable {}
extension FogLedger_BlockData: @unchecked Sendable {}
extension FogLedger_TxOutRequest: @unchecked Sendable {}
extension FogLedger_TxOutResponse: @unchecked Sendable {}
extension FogLedger_TxOutResult: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fog_ledger"

extension FogLedger_MultiKeyImageStoreResponseStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "AUTHENTICATION_ERROR"),
    3: .same(proto: "NOT_READY"),
    4: .same(proto: "INVALID_ARGUMENT"),
  ]
}

extension FogLedger_OutputResultCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IntentionallyUnused"),
    1: .same(proto: "DoesNotExist"),
    2: .same(proto: "Exists"),
    3: .same(proto: "OutputDatabaseError"),
  ]
}

extension FogLedger_KeyImageResultCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unused"),
    1: .same(proto: "Spent"),
    2: .same(proto: "NotSpent"),
    3: .same(proto: "KeyImageError"),
  ]
}

extension FogLedger_TxOutResultCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotFound"),
    1: .same(proto: "Found"),
    2: .same(proto: "MalformedRequest"),
    3: .same(proto: "DatabaseError"),
  ]
}

extension FogLedger_LedgerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LedgerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "check_key_images"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Attest_AuthMessage?
        var hadOneofValue = false
        if let current = self.requestData {
          hadOneofValue = true
          if case .auth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestData = .auth(v)
        }
      }()
      case 2: try {
        var v: Attest_Message?
        var hadOneofValue = false
        if let current = self.requestData {
          hadOneofValue = true
          if case .checkKeyImages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestData = .checkKeyImages(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.requestData {
    case .auth?: try {
      guard case .auth(let v)? = self.requestData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .checkKeyImages?: try {
      guard case .checkKeyImages(let v)? = self.requestData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_LedgerRequest, rhs: FogLedger_LedgerRequest) -> Bool {
    if lhs.requestData != rhs.requestData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_LedgerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LedgerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "check_key_image_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Attest_AuthMessage?
        var hadOneofValue = false
        if let current = self.responseData {
          hadOneofValue = true
          if case .auth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseData = .auth(v)
        }
      }()
      case 2: try {
        var v: Attest_Message?
        var hadOneofValue = false
        if let current = self.responseData {
          hadOneofValue = true
          if case .checkKeyImageResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseData = .checkKeyImageResponse(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.responseData {
    case .auth?: try {
      guard case .auth(let v)? = self.responseData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .checkKeyImageResponse?: try {
      guard case .checkKeyImageResponse(let v)? = self.responseData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_LedgerResponse, rhs: FogLedger_LedgerResponse) -> Bool {
    if lhs.responseData != rhs.responseData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_FogLedgerStoreDecryptionError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FogLedgerStoreDecryptionError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "store_uri"),
    2: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storeUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.storeUri, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_FogLedgerStoreDecryptionError, rhs: FogLedger_FogLedgerStoreDecryptionError) -> Bool {
    if lhs.storeUri != rhs.storeUri {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_MultiKeyImageStoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiKeyImageStoreRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_MultiKeyImageStoreRequest, rhs: FogLedger_MultiKeyImageStoreRequest) -> Bool {
    if lhs.queries != rhs.queries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_MultiKeyImageStoreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiKeyImageStoreResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "query_response"),
    2: .standard(proto: "store_uri"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._queryResponse) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.storeUri) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._queryResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.storeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.storeUri, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_MultiKeyImageStoreResponse, rhs: FogLedger_MultiKeyImageStoreResponse) -> Bool {
    if lhs._queryResponse != rhs._queryResponse {return false}
    if lhs.storeUri != rhs.storeUri {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_GetOutputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOutputsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "indices"),
    2: .standard(proto: "merkle_root_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed64Field(value: &self.indices) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.merkleRootBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indices.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.indices, fieldNumber: 1)
    }
    if self.merkleRootBlock != 0 {
      try visitor.visitSingularFixed64Field(value: self.merkleRootBlock, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_GetOutputsRequest, rhs: FogLedger_GetOutputsRequest) -> Bool {
    if lhs.indices != rhs.indices {return false}
    if lhs.merkleRootBlock != rhs.merkleRootBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_GetOutputsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOutputsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    2: .standard(proto: "num_blocks"),
    3: .standard(proto: "global_txo_count"),
    4: .standard(proto: "latest_block_version"),
    5: .standard(proto: "max_block_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numBlocks) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.globalTxoCount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.latestBlockVersion) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.maxBlockVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if self.numBlocks != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBlocks, fieldNumber: 2)
    }
    if self.globalTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.globalTxoCount, fieldNumber: 3)
    }
    if self.latestBlockVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.latestBlockVersion, fieldNumber: 4)
    }
    if self.maxBlockVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxBlockVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_GetOutputsResponse, rhs: FogLedger_GetOutputsResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.numBlocks != rhs.numBlocks {return false}
    if lhs.globalTxoCount != rhs.globalTxoCount {return false}
    if lhs.latestBlockVersion != rhs.latestBlockVersion {return false}
    if lhs.maxBlockVersion != rhs.maxBlockVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_OutputResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "result_code"),
    3: .same(proto: "output"),
    4: .same(proto: "proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.resultCode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._output) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._proof) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularFixed64Field(value: self.index, fieldNumber: 1)
    }
    if self.resultCode != 0 {
      try visitor.visitSingularFixed32Field(value: self.resultCode, fieldNumber: 2)
    }
    try { if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._proof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_OutputResult, rhs: FogLedger_OutputResult) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs._output != rhs._output {return false}
    if lhs._proof != rhs._proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_CheckKeyImagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckKeyImagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_CheckKeyImagesRequest, rhs: FogLedger_CheckKeyImagesRequest) -> Bool {
    if lhs.queries != rhs.queries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_KeyImageQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyImageQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_image"),
    2: .standard(proto: "start_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyImage) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.startBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.startBlock != 0 {
      try visitor.visitSingularFixed64Field(value: self.startBlock, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_KeyImageQuery, rhs: FogLedger_KeyImageQuery) -> Bool {
    if lhs._keyImage != rhs._keyImage {return false}
    if lhs.startBlock != rhs.startBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_CheckKeyImagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckKeyImagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_blocks"),
    2: .standard(proto: "global_txo_count"),
    3: .same(proto: "results"),
    4: .standard(proto: "latest_block_version"),
    5: .standard(proto: "max_block_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.numBlocks) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.globalTxoCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.latestBlockVersion) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.maxBlockVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numBlocks != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBlocks, fieldNumber: 1)
    }
    if self.globalTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.globalTxoCount, fieldNumber: 2)
    }
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 3)
    }
    if self.latestBlockVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.latestBlockVersion, fieldNumber: 4)
    }
    if self.maxBlockVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxBlockVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_CheckKeyImagesResponse, rhs: FogLedger_CheckKeyImagesResponse) -> Bool {
    if lhs.numBlocks != rhs.numBlocks {return false}
    if lhs.globalTxoCount != rhs.globalTxoCount {return false}
    if lhs.results != rhs.results {return false}
    if lhs.latestBlockVersion != rhs.latestBlockVersion {return false}
    if lhs.maxBlockVersion != rhs.maxBlockVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_KeyImageResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyImageResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_image"),
    2: .standard(proto: "spent_at"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "timestamp_result_code"),
    5: .standard(proto: "key_image_result_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyImage) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.spentAt) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.timestampResultCode) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self.keyImageResultCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.spentAt != 0 {
      try visitor.visitSingularFixed64Field(value: self.spentAt, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularFixed64Field(value: self.timestamp, fieldNumber: 3)
    }
    if self.timestampResultCode != 0 {
      try visitor.visitSingularFixed32Field(value: self.timestampResultCode, fieldNumber: 4)
    }
    if self.keyImageResultCode != 0 {
      try visitor.visitSingularFixed32Field(value: self.keyImageResultCode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_KeyImageResult, rhs: FogLedger_KeyImageResult) -> Bool {
    if lhs._keyImage != rhs._keyImage {return false}
    if lhs.spentAt != rhs.spentAt {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.timestampResultCode != rhs.timestampResultCode {return false}
    if lhs.keyImageResultCode != rhs.keyImageResultCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_BlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ranges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_BlockRequest, rhs: FogLedger_BlockRequest) -> Bool {
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_BlockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
    2: .standard(proto: "num_blocks"),
    3: .standard(proto: "global_txo_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numBlocks) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.globalTxoCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 1)
    }
    if self.numBlocks != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBlocks, fieldNumber: 2)
    }
    if self.globalTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.globalTxoCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_BlockResponse, rhs: FogLedger_BlockResponse) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs.numBlocks != rhs.numBlocks {return false}
    if lhs.globalTxoCount != rhs.globalTxoCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_BlockData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "global_txo_count"),
    3: .same(proto: "outputs"),
    4: .same(proto: "timestamp"),
    5: .standard(proto: "timestamp_result_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.globalTxoCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.timestampResultCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 1)
    }
    if self.globalTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.globalTxoCount, fieldNumber: 2)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.timestampResultCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampResultCode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_BlockData, rhs: FogLedger_BlockData) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.globalTxoCount != rhs.globalTxoCount {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.timestampResultCode != rhs.timestampResultCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_TxOutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_out_pubkeys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.txOutPubkeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txOutPubkeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txOutPubkeys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_TxOutRequest, rhs: FogLedger_TxOutRequest) -> Bool {
    if lhs.txOutPubkeys != rhs.txOutPubkeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_TxOutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    2: .standard(proto: "num_blocks"),
    3: .standard(proto: "global_txo_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numBlocks) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.globalTxoCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if self.numBlocks != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBlocks, fieldNumber: 2)
    }
    if self.globalTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.globalTxoCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_TxOutResponse, rhs: FogLedger_TxOutResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.numBlocks != rhs.numBlocks {return false}
    if lhs.globalTxoCount != rhs.globalTxoCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FogLedger_TxOutResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_out_pubkey"),
    2: .standard(proto: "result_code"),
    3: .standard(proto: "tx_out_global_index"),
    4: .standard(proto: "block_index"),
    5: .same(proto: "timestamp"),
    6: .standard(proto: "timestamp_result_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._txOutPubkey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.txOutGlobalIndex) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.blockIndex) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.timestampResultCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._txOutPubkey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.resultCode != .notFound {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 2)
    }
    if self.txOutGlobalIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.txOutGlobalIndex, fieldNumber: 3)
    }
    if self.blockIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockIndex, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 5)
    }
    if self.timestampResultCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampResultCode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogLedger_TxOutResult, rhs: FogLedger_TxOutResult) -> Bool {
    if lhs._txOutPubkey != rhs._txOutPubkey {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.txOutGlobalIndex != rhs.txOutGlobalIndex {return false}
    if lhs.blockIndex != rhs.blockIndex {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.timestampResultCode != rhs.timestampResultCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
