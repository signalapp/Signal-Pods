// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: blockchain.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018-2022 The MobileCoin Foundation

// Blockchain-related data types.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Block ID.
public struct Blockchain_BlockID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Hash of the block's contents.
public struct Blockchain_BlockContentsHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A block in the blockchain.
public struct Blockchain_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Block ID.
  public var id: Blockchain_BlockID {
    get {return _id ?? Blockchain_BlockID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// Block format version.
  public var version: UInt32 = 0

  /// Id of the previous block.
  public var parentID: Blockchain_BlockID {
    get {return _parentID ?? Blockchain_BlockID()}
    set {_parentID = newValue}
  }
  /// Returns true if `parentID` has been explicitly set.
  public var hasParentID: Bool {return self._parentID != nil}
  /// Clears the value of `parentID`. Subsequent reads from it will return its default value.
  public mutating func clearParentID() {self._parentID = nil}

  /// The index of this block in the blockchain.
  public var index: UInt64 = 0

  /// The cumulative number of TXOs in the blockchain, including this block
  public var cumulativeTxoCount: UInt64 = 0

  /// Root hash of the membership proofs provided by the untrusted local system for validation.
  /// This captures the state of all TxOuts in the ledger that this block was validated against.
  public var rootElement: External_TxOutMembershipElement {
    get {return _rootElement ?? External_TxOutMembershipElement()}
    set {_rootElement = newValue}
  }
  /// Returns true if `rootElement` has been explicitly set.
  public var hasRootElement: Bool {return self._rootElement != nil}
  /// Clears the value of `rootElement`. Subsequent reads from it will return its default value.
  public mutating func clearRootElement() {self._rootElement = nil}

  /// Hash of the block's contents.
  public var contentsHash: Blockchain_BlockContentsHash {
    get {return _contentsHash ?? Blockchain_BlockContentsHash()}
    set {_contentsHash = newValue}
  }
  /// Returns true if `contentsHash` has been explicitly set.
  public var hasContentsHash: Bool {return self._contentsHash != nil}
  /// Clears the value of `contentsHash`. Subsequent reads from it will return its default value.
  public mutating func clearContentsHash() {self._contentsHash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Blockchain_BlockID? = nil
  fileprivate var _parentID: Blockchain_BlockID? = nil
  fileprivate var _rootElement: External_TxOutMembershipElement? = nil
  fileprivate var _contentsHash: Blockchain_BlockContentsHash? = nil
}

public struct Blockchain_BlockContents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key images spent in this block.
  public var keyImages: [External_KeyImage] = []

  /// Outputs created in this block.
  public var outputs: [External_TxOut] = []

  //// mint-config transactions in this block coupled with data used to validate them.
  public var validatedMintConfigTxs: [External_ValidatedMintConfigTx] = []

  //// Mint transactions in this block.
  public var mintTxs: [External_MintTx] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Blockchain_BlockSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The signature of the block.
  public var signature: External_Ed25519Signature {
    get {return _signature ?? External_Ed25519Signature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  /// The signer that generated the above signature.
  public var signer: External_Ed25519Public {
    get {return _signer ?? External_Ed25519Public()}
    set {_signer = newValue}
  }
  /// Returns true if `signer` has been explicitly set.
  public var hasSigner: Bool {return self._signer != nil}
  /// Clears the value of `signer`. Subsequent reads from it will return its default value.
  public mutating func clearSigner() {self._signer = nil}

  /// An approximate time in which the block was signed.
  /// Represented as seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.
  public var signedAt: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _signature: External_Ed25519Signature? = nil
  fileprivate var _signer: External_Ed25519Public? = nil
}

/// Version 1 of an archived block.
/// Note: The block.version field within the block may or may not be equal to 1.
public struct Blockchain_ArchiveBlockV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Block
  public var block: Blockchain_Block {
    get {return _block ?? Blockchain_Block()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {self._block = nil}

  /// Contents of the block.
  public var blockContents: Blockchain_BlockContents {
    get {return _blockContents ?? Blockchain_BlockContents()}
    set {_blockContents = newValue}
  }
  /// Returns true if `blockContents` has been explicitly set.
  public var hasBlockContents: Bool {return self._blockContents != nil}
  /// Clears the value of `blockContents`. Subsequent reads from it will return its default value.
  public mutating func clearBlockContents() {self._blockContents = nil}

  /// Block signature, when available.
  public var signature: Blockchain_BlockSignature {
    get {return _signature ?? Blockchain_BlockSignature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _block: Blockchain_Block? = nil
  fileprivate var _blockContents: Blockchain_BlockContents? = nil
  fileprivate var _signature: Blockchain_BlockSignature? = nil
}

/// An archived block.
public struct Blockchain_ArchiveBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var block: Blockchain_ArchiveBlock.OneOf_Block? = nil

  public var v1: Blockchain_ArchiveBlockV1 {
    get {
      if case .v1(let v)? = block {return v}
      return Blockchain_ArchiveBlockV1()
    }
    set {block = .v1(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Block: Equatable {
    case v1(Blockchain_ArchiveBlockV1)

  #if !swift(>=4.1)
    public static func ==(lhs: Blockchain_ArchiveBlock.OneOf_Block, rhs: Blockchain_ArchiveBlock.OneOf_Block) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v1, .v1): return {
        guard case .v1(let l) = lhs, case .v1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// A collection of archived blocks.
public struct Blockchain_ArchiveBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blocks: [Blockchain_ArchiveBlock] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Blockchain_BlockID: @unchecked Sendable {}
extension Blockchain_BlockContentsHash: @unchecked Sendable {}
extension Blockchain_Block: @unchecked Sendable {}
extension Blockchain_BlockContents: @unchecked Sendable {}
extension Blockchain_BlockSignature: @unchecked Sendable {}
extension Blockchain_ArchiveBlockV1: @unchecked Sendable {}
extension Blockchain_ArchiveBlock: @unchecked Sendable {}
extension Blockchain_ArchiveBlock.OneOf_Block: @unchecked Sendable {}
extension Blockchain_ArchiveBlocks: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "blockchain"

extension Blockchain_BlockID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_BlockID, rhs: Blockchain_BlockID) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_BlockContentsHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockContentsHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_BlockContentsHash, rhs: Blockchain_BlockContentsHash) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Block"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "version"),
    3: .standard(proto: "parent_id"),
    4: .same(proto: "index"),
    5: .standard(proto: "cumulative_txo_count"),
    6: .standard(proto: "root_element"),
    7: .standard(proto: "contents_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._parentID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.cumulativeTxoCount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._rootElement) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._contentsHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    try { if let v = self._parentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 4)
    }
    if self.cumulativeTxoCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.cumulativeTxoCount, fieldNumber: 5)
    }
    try { if let v = self._rootElement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._contentsHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_Block, rhs: Blockchain_Block) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.version != rhs.version {return false}
    if lhs._parentID != rhs._parentID {return false}
    if lhs.index != rhs.index {return false}
    if lhs.cumulativeTxoCount != rhs.cumulativeTxoCount {return false}
    if lhs._rootElement != rhs._rootElement {return false}
    if lhs._contentsHash != rhs._contentsHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_BlockContents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockContents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_images"),
    2: .same(proto: "outputs"),
    3: .standard(proto: "validated_mint_config_txs"),
    4: .standard(proto: "mint_txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keyImages) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.validatedMintConfigTxs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.mintTxs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyImages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyImages, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    if !self.validatedMintConfigTxs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validatedMintConfigTxs, fieldNumber: 3)
    }
    if !self.mintTxs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mintTxs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_BlockContents, rhs: Blockchain_BlockContents) -> Bool {
    if lhs.keyImages != rhs.keyImages {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.validatedMintConfigTxs != rhs.validatedMintConfigTxs {return false}
    if lhs.mintTxs != rhs.mintTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_BlockSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockSignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .same(proto: "signer"),
    3: .standard(proto: "signed_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signer) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.signedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.signedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.signedAt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_BlockSignature, rhs: Blockchain_BlockSignature) -> Bool {
    if lhs._signature != rhs._signature {return false}
    if lhs._signer != rhs._signer {return false}
    if lhs.signedAt != rhs.signedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_ArchiveBlockV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveBlockV1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .standard(proto: "block_contents"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockContents) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._blockContents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_ArchiveBlockV1, rhs: Blockchain_ArchiveBlockV1) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs._blockContents != rhs._blockContents {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_ArchiveBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v1"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Blockchain_ArchiveBlockV1?
        var hadOneofValue = false
        if let current = self.block {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.block = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v1(let v)? = self.block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_ArchiveBlock, rhs: Blockchain_ArchiveBlock) -> Bool {
    if lhs.block != rhs.block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blockchain_ArchiveBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blockchain_ArchiveBlocks, rhs: Blockchain_ArchiveBlocks) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
